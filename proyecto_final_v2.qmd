---
title: "Proyecto final Series de Tiempo 2025 Otoño Invierno"
format: 
  revealjs:
    scrollable: true
    incremental: true
    smaller: true
    theme: default
    embed-resources: true
execute:
  echo: true
  output-location: column-fragment
---

```{r}
#| echo: false
#| warning: false
#| message: false

library(tidyquant)
library(tidyverse)
library(tsibble)
library(lubridate)
library(dplyr)
library(tidyr)
library(ggplot2)
library(stringr)
library(glue)
library(ggtime)
library(plotly)
library(fpp3)
library(fable)
library(fabletools)
library(feasts)
library(fable.prophet)
```

## Tienda Delicatessen

Vende principalmente **embutidos** (**carnes frías**) y **quesos** y productos derivados de ello (charolas de carnes frías/quesos, baguettes, etc.).

Tiene horario de lunes a viernes de 10:00 a 19:00 horas y sábados de 10:00 a 15:00 horas (cerrada los domingos).

```{r}
load("C:/Users/hecto/Downloads/proyecto_final (1).RData")
datos_tsb

datos_tsb |> 
  autoplot(total)
```

## Tratamiento de Datos

```{r}
ventas <- datos_tsb |>
  mutate(
    hour = floor_date(fecha, unit = "hour")  # por si hubiera minutos/segundos
  ) |>
  index_by(hour) |>
  summarise(
    total = sum(total)   # ventas totales por hora
  )
ventas |> tail()
```

### Tratamiento de Outliers

```{r}
ventas |> gg_tsdisplay(total)

```

#### Comportamiento general

-   La mayoría de los valores horarios están **entre 0 y 2 000 unidades**.

-   Hay **picos extremadamente altos** (20 000, 40 000, 70 000+), lo que indica **outliers claros**

#### Tipo de Outlier

Dada la magnitud y rareza: Son probablemente **aditivos**, es decir valores puntuales anómalos, no parecen cambios estructurales ni patrones recurrentes.

El gráfico ACF tiene un pico muy alto en en lag 1, sugiriendo una estacionalidad horaria alta, de la misma forma en el lag 24; marcando la estacionalidad diaria. Para hacer el tratamiento de outliers se hará una descomposición de la serie utilizando STL, los outliers se determinarán con el componente de residuo con la siguiente lógica:

Outlier si se cumple: `|remainder| > 3*sd(remainder)`

```{r}
ventas_stl <- ventas |>
  model(stl = STL(total ~ season(window = "periodic")))

ventas_stl |>
  components() |>
  autoplot()

ventas_stl_components <- components(ventas_stl)

ventas_outliers <- ventas_stl_components |>
  as_tibble() |>
  mutate(
    is_outlier = remainder < quantile(remainder, 0.25) - 3 * IQR(remainder) |
                 remainder > quantile(remainder, 0.75) + 3 * IQR(remainder)
  ) |>
  as_tsibble(index = hour)
  


ventas_outliers |>
  ggplot(aes(x = hour, y = total, color = is_outlier)) +
  geom_point()



```

```{r}
#ventas_clean <- ventas_outliers |>
#  mutate(
#    total = if_else(is_outlier, NA_real_, total)
#  ) |>
#  as_tsibble(index = hour)

ventas_clean <- ventas_outliers |>
  # 1. Quitar los outliers para crear huecos
  mutate(
    total = if_else(is_outlier, NA_real_, total)
  ) |>
  
  # 2. Asegurar que todos los huecos queden explícitos
  fill_gaps() |>
  
  # 3. Ajustar ARIMA permitiendo NA
  model(arima = ARIMA(total)) |>
  
  # 4. Interpolar usando el modelo
  interpolate(
    ventas_outliers |>
      mutate(
        total = if_else(is_outlier, NA_real_, total)
      ) |>
      fill_gaps()
  )


ventas_clean |> 
  autoplot(total)

```

```{r}
ventas_tienda <- ventas_clean |>
  mutate(
    hour = floor_date(hour, unit = "hour")  # por si hubiera minutos/segundos
  ) |>
  index_by(hour) |>
  summarise(
    total = sum(total)   # ventas totales por hora
  ) |>
  mutate(
    day_type = case_when(
      wday(hour, week_start = 1) %in% c(6, 7) ~ "Weekend",
      TRUE ~ "Weekday"
    ),
    work_day = day_type == "Weekday"
  )

ventas_tienda
```

## Modelos

Separación de train y test:

```{r}
ventas_tienda_train <- ventas_tienda |>
  filter_index(. ~ "2025-04-08 19:00:00")

ventas_tienda_test <- ventas_tienda |>
  filter_index("2025-04-08 19:00:00" ~ .)

```

```{r}
# 2) (opcional) entrenamiento = todo lo observado
#ventas_tienda_train <- ventas_tienda

# 3) Horizonte: horas hasta el último día de noviembre 2025
last_obs   <- max(ventas_tienda_train$hour)
target_end <- lubridate::ymd_h("2025-11-31 23") #1 mes por fines prácticos del modelo

h_ventas <- as.numeric(
  difftime(target_end, last_obs, units = "hours")
)

h_ventas  
```

```{r}
ventas_tienda_fit <- ventas_tienda_train |> 
  model(
    # 1) TSLM: trend + season (season() crea regresores para la estacionalidad detectada)
    tslm = TSLM(total ~ trend() + season()),

    # 2) STL decomposition: modelamos la serie desestacionalizada con TSLM (captura drift/trend)
    #    y usamos SNAIVE para la componente estacional (si no se pone, SNAIVE es por defecto).
    stl_dcmp = decomposition_model(
      STL(total ~ season(window = "periodic")),    # descomposición (ventana periódica = season fija)
      TSLM(season_adjust ~ trend()),                # modelamos season_adjust (drift vía trend())
      SNAIVE(season_year)                           # explicitamos SNAIVE para la componente seasonal
    ),

    # 3) SNAIVE: benchmark estacional sobre la serie original
    snaive = SNAIVE(total),

    # 4) ETS: modelo ETS automático (selección por AICc)
    ets = ETS(total),
    
    # 5) ARIMA estándar
    arima = ARIMA(total),
    
    # 6) Regresión armónica dinámica (Fourier + ARIMA + work_day)
    dhr = ARIMA(
      total ~ fourier("day",  K = 6) +
               fourier("week", K = 3) +
               work_day
    ),

    # 7) Prophet
    prophet = prophet(
      total ~ growth("linear") +
        season("week") +
        season("year")
    )
    
  )
```

### Forecast

```{r}
library(fabletools)  # por si acaso

# Datos futuros solo con el índice 'hour'
ventas_future <- ventas_tienda_train |>
  new_data(n = h_ventas) |>
  mutate(
    day_type = case_when(
      lubridate::wday(hour, week_start = 1) %in% c(6, 7) ~ "Weekend",
      TRUE ~ "Weekday"
    ),
    work_day = day_type == "Weekday"
  )

# Ahora sí, pronósticos de TODOS los modelos (incluyendo dhr)
fc <- ventas_tienda_fit |>
  forecast(new_data = ventas_future)
```

### Métricas de Desempeño

```{r}
fc |> 
  accuracy(ventas_tienda_test) |> 
  arrange(MAE)
```

### Visualización

```{r}
p <- fc |>
  autoplot(ventas_tienda_test, level = NULL) +
  labs(
    title = "Pronósticos vs datos reales (periodo de prueba)",
    x = "Fecha y hora",
    y = "Total"
  )

p_int <- p |>
  ggplotly(dynamicTicks = TRUE) |>
  layout(
    xaxis = list(
      rangeslider = list(visible = TRUE)
    )
  )

p_int

```

## Conclusiones

Conclusiones \[...\]

### Exportación del modelo

```{r}
equipo_x <- fc |> 
  filter(.model == "stl_dcmp")
  

save(equipo_x, file = "fc_equipo_x.RData")
```
