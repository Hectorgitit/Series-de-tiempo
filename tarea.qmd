---
title: "Serie de electricidad"
format: 
  revealjs:
    scrollable: true
    incremental: true
    smaller: true
    theme: default
    embed-resources: true
execute:
  echo: true
  output-location: column-fragment
---


```{r}
#| echo: false
#| warning: false
#| message: false
# --- ARIMA por serie + LM (fórmula automática según columnas disponibles) ---

library(tidyquant)
library(tsibble)
library(fable)
library(fabletools)
library(feasts)
library(lubridate)
library(dplyr)
library(tidyr)
library(ggplot2)
library(stringr)
library(glue)
```

```{r}
#| echo: false
#| warning: false
#| message: false
h_meses <- 36
y_var   <- "IPN221114T8N"   
escala_opt <- 0.97          
escala_pes <- 1.03           
```



¿Qué buscamos pronosticar?




## Serie IPN221114T8N

Volumen de la generación eléctrica, pero **¿De qué fuentes?**

De las NAICS (North American Industry Classification System)
NAICS 221114–221118:

-221114 **Solar**

-221115 **Eólica**

-221116 **Geotérmica**

-221117 **Biomasa**

-221118 **Otras**

Es decir, no incluye: 

-221112 Fossil Fuel Electric Power Generation (**carbón**, **gas natural**, **fuel-oil**)

-221113 **Nuclear**

-221111 **Hidroeléctrica** (renovable, pero va aparte en NAICS)



```{r}
#| echo: false
#| warning: false
#| message: false
#| fig.show: hold

# 1) Descargar y preparar
ip_renov_us_raw <- tq_get("IPN221114T8N", get = "economic.data") |>
  transmute(mes = yearmonth(date), valor = price)

ip_renov_us <- ip_renov_us_raw |>
  group_by(mes) |>
  summarise(valor = mean(valor, na.rm = TRUE), .groups = "drop") |>
  as_tsibble(index = mes)

# 2) Calidad de datos (sin imprimir en el render)
invisible(glimpse(ip_renov_us))
invisible(interval(ip_renov_us))
invisible(has_gaps(ip_renov_us)); invisible(count_gaps(ip_renov_us))

# 3) Serie, STL y estacionalidad (asignar y luego imprimir)

# Serie
p1 <- autoplot(ip_renov_us, valor) +
  labs(title = "IPN221114T8N – índice (2017=100, no ajustado)", x = NULL, y = NULL)
print(p1)

# STL
stl_comps <- ip_renov_us |>
  model(STL(valor ~ trend(window = 13) + season(window = "periodic"))) |>
  components()
p2 <- autoplot(stl_comps) +
  labs(title = "Descomposición STL")
print(p2)

# Estacionalidad por mes
p3 <- gg_season(ip_renov_us, valor) +
  labs(title = "Estacionalidad por mes", x = "Mes", y = NULL)
print(p3)

# 4) Fuerza de tendencia/estacionalidad (calculado pero NO mostrado)
feats <- ip_renov_us |>
  features(valor, feat_stl) |>
  select(trend_strength, seasonal_strength_year)
invisible(feats)

# Evitar auto-impresión al final del chunk
invisible(NULL)
```
```{r}
# 2) Calidad de datos
glimpse(ip_renov_us)
interval(ip_renov_us)
has_gaps(ip_renov_us); count_gaps(ip_renov_us)

# 3) Serie, STL y estacionalidad
autoplot(ip_renov_us, valor) +
  labs(title = "IPN221114T8N – índice (2017=100, no ajustado)", x = NULL, y = NULL)

ip_renov_us |>
  model(STL(valor ~ trend(window = 13) + season(window = "periodic"))) |>
  components() |>
  autoplot() +
  labs(title = "Descomposición STL")

gg_season(ip_renov_us, valor) +
  labs(title = "Estacionalidad por mes", x = "Mes", y = NULL)
```


## ¿Qué sería lo lógico?
Buscar series que no sean redundantes con energías renovables.

MHHNGSP - **Precio spot del gas natural** en el punto Henry Hub (referencia para EE. UU.).

WPS0554 - **Índice de precios al productor para gas natural** destinado a la generación eléctrica.

NATURALGAS - **Consumo total de gas natural** en EE. UU.

##

DCOILWTICO - **Precio promedio del petróleo crudo** WTI (referencia mundial).

IPUTIL - **Producción industrial real del sector de servicios públicos** (electricidad, agua, gas).

APU000072610 - **Precio promedio minorista de la electricidad** en hogares de EE. UU.

INDPRO - **Producción industrial** total de EE. UU. (todos los sectores).

CPIENGSL - CPI: “Energy Services” (electricidad + gas para el hogar) – **consumidores urbanos**.

```{r}
#| echo: false
#| warning: false
#| message: false

# 1) Lista deseada (si alguna no existe en FRED o falla la conexión, la omitiremos)
vars_fred <- c(
  "IPN221114T8N",                 # objetivo
  "MHHNGSP","WPS0554","NATURALGAS","DCOILWTICO","IPUTIL",
  "GASPRICE","APU000072610","CO2EMISS","INDPRO","TEMPUS","CPIENGSL"
)
vars_fred

```

```{r}
#| echo: false
#| warning: false
#| message: false
# 2) Descargar y mensualizar
energia_raw <- tq_get(vars_fred, get = "economic.data") |>
  rename(serie = symbol, valor = price)
energia_raw
```

```{r}
#| echo: false
#| warning: false
#| message: false
# 2.1) Reportar qué series sí bajaron y cuáles faltaron
series_ok  <- energia_raw |> distinct(serie) |> pull(serie)
series_out <- setdiff(vars_fred, series_ok)
message("Series descargadas: ", paste(series_ok, collapse = ", "))
if (length(series_out) > 0) {
  message("⚠️ No se descargaron (se excluirán): ", paste(series_out, collapse = ", "))
}
series_ok
```

```{r}

energia_mensual_tsb <- energia_raw |>
  transmute(serie, mes = yearmonth(date), valor) |>
  group_by(serie, mes) |>
  summarise(valor = mean(valor, na.rm = TRUE), .groups = "drop") |>
  as_tsibble(index = mes, key = serie) |>
  arrange(serie, mes)
energia_mensual_tsb
```

```{r}
#| echo: false

# Panel WIDE con observadas (Y + X) a partir de energia_mensual_tsb

energia_panel_wide <- energia_mensual_tsb |>
dplyr::as_tibble() |>
tidyr::pivot_wider(names_from = serie, values_from = valor) |>
dplyr::arrange(mes) |>
tsibble::as_tsibble(index = mes)

# Selección de regresores disponibles

candidatas_x <- setdiff(vars_fred, y_var)
x_vars <- intersect(candidatas_x, names(energia_panel_wide))

stopifnot(y_var %in% names(energia_panel_wide), length(x_vars) > 0)

# Fórmula ARIMAX (órdenes auto + xregs)

fmla_arimax <- as.formula(paste(y_var, "~", paste(x_vars, collapse = " + ")))

# Datos limpios (sin NA en Y ni X)

energia_reg <- energia_panel_wide |>
dplyr::select(mes, dplyr::all_of(c(y_var, x_vars))) |>
tidyr::drop_na()

# Ajuste ARIMAX

energia_arimax_fit <- energia_reg |>
fabletools::model(arimax = fable::ARIMA(fmla_arimax))

# Diagnóstico breve

fabletools::report(energia_arimax_fit)

```


```{r}
datos_reg <- energia_ajustada_wide |>
  drop_na()

# Modelo con todo el historial (para ex-ante)
modelo_reg_all <- lm(fmla, data = datos_reg)
```

```{r}
#MHHNGSP - Precio spot del gas natural en el punto Henry Hub (referencia para EE. UU.).
#WPS0554 - Índice de precios al productor para gas natural destinado a la generación eléctrica.
#NATURALGAS - Consumo total de gas natural en EE. UU.
#DCOILWTICO - Precio promedio del petróleo crudo WTI (referencia mundial).
#IPUTIL - Producción industrial real del sector de servicios públicos (electricidad, agua, gas).
#APU000072610 - Precio promedio minorista de la electricidad en hogares de EE. UU.
#INDPRO - Producción industrial total de EE. UU. (todos los sectores).
```

```{r}
# 7) Estrellitas, R^2, R^2 ajustado, p-value global
summary(modelo_reg_all)

```


## Eliminamos una variable no significativa
Optimización 1

```{r}
#| echo: false

# Elimina una X, actualiza fórmula y re-ajusta ARIMAX

var_out <- "NATURALGAS"   # <-- cambia aquí el nombre a eliminar
resp <- all.vars(fmla_arimax)[1]
xs   <- setdiff(all.vars(fmla_arimax)[-1], var_out)
stopifnot(length(xs) > 0)
fmla_arimax <- reformulate(xs, response = resp)

energia_arimax_fit <- energia_reg |>
fabletools::model(arimax = fable::ARIMA(fmla_arimax))

fabletools::report(energia_arimax_fit)

```


## Eliminamos otra variable no significativa
Optimización 2
```{r}
#| echo: false

# Elimina una X, actualiza fórmula y re-ajusta ARIMAX

var_out <- "DCOILWTICO"   # <-- cambia aquí el nombre a eliminar
resp <- all.vars(fmla_arimax)[1]
xs   <- setdiff(all.vars(fmla_arimax)[-1], var_out)
stopifnot(length(xs) > 0)
fmla_arimax <- reformulate(xs, response = resp)

energia_arimax_fit <- energia_reg |>
fabletools::model(arimax = fable::ARIMA(fmla_arimax))

fabletools::report(energia_arimax_fit)

```

## Eliminamos otra variable no significativa
Optimización 3

```{r}
#| echo: false

# Elimina una X, actualiza fórmula y re-ajusta ARIMAX

var_out <- "WPS0554"   # <-- cambia aquí el nombre a eliminar
resp <- all.vars(fmla_arimax)[1]
xs   <- setdiff(all.vars(fmla_arimax)[-1], var_out)
stopifnot(length(xs) > 0)
fmla_arimax <- reformulate(xs, response = resp)

energia_arimax_fit <- energia_reg |>
fabletools::model(arimax = fable::ARIMA(fmla_arimax))

fabletools::report(energia_arimax_fit)

```


## Eliminamos ya la última no significativa
Optimización 4

```{r}
#| echo: false

# Elimina una X, actualiza fórmula y re-ajusta ARIMAX

var_out <- "APU000072610"   # <-- cambia aquí el nombre a eliminar
resp <- all.vars(fmla_arimax)[1]
xs   <- setdiff(all.vars(fmla_arimax)[-1], var_out)
stopifnot(length(xs) > 0)
fmla_arimax <- reformulate(xs, response = resp)

energia_arimax_fit <- energia_reg |>
fabletools::model(arimax = fable::ARIMA(fmla_arimax))

fabletools::report(energia_arimax_fit)

```

## Reflexión
En el caso de esta regresión en específico solo eliminares el consumo total de gas natural en EU ya que las demas solo reducen el R cuadrado ajustado, lo cual es lo que se puede explicar de la variable a pronosticar.

```{r}
#| echo: false

# Horizonte

h_meses <- 36

# Corte temporal

ultimo_mes <- max(energia_reg$mes)
corte_test <- ultimo_mes - (h_meses - 1)

train <- energia_reg |> dplyr::filter(mes <  corte_test)
test  <- energia_reg |> dplyr::filter(mes >= corte_test)

# Re-ajustar ARIMAX en TRAIN

fit_train <- train |> fabletools::model(arimax = fable::ARIMA(fmla_arimax))

# Pronóstico sobre TEST (X observadas)

fc_test <- fabletools::forecast(
fit_train,
new_data = test |> dplyr::select(mes, dplyr::all_of(setdiff(all.vars(fmla_arimax), all.vars(fmla_arimax)[1])))
)

# Métricas contra Y observada

acc_test <- fabletools::accuracy(fc_test, test)
acc_test

```


```{r}
#| echo: false

# Pronóstico ARIMA(h) para cada X

x_vars <- setdiff(all.vars(fmla_arimax), all.vars(fmla_arimax)[1])
x_series <- energia_mensual_tsb |> dplyr::filter(serie %in% x_vars)

x_fit <- x_series |> fabletools::model(auto = fable::ARIMA(valor))

x_fc <- x_fit |>
fabletools::forecast(h = h_meses) |>
dplyr::select(serie, mes, .mean) |>
dplyr::rename(valor_fc = .mean) |>
dplyr::mutate(valor_fc = as.numeric(valor_fc)) |>
tidyr::pivot_wider(names_from = serie, values_from = valor_fc) |>
dplyr::arrange(mes)

# Alinear con el último mes observado de Y

ultimo_hist <- max(energia_reg$mes)
x_fc_aligned <- x_fc |>
dplyr::filter(mes > ultimo_hist) |>
tidyr::drop_na(dplyr::all_of(x_vars)) |>
dplyr::slice_head(n = h_meses)

# Ex–ante (base)

fc_exante <- fabletools::forecast(
energia_arimax_fit,
new_data = x_fc_aligned |> dplyr::select(mes, dplyr::all_of(x_vars))
)

fc_exante

```

```{r}
#| echo: false
escala_opt <- 0.97  # -3%
escala_pes <- 1.03  # +3%

newdata_scen <- fabletools::scenarios(
base =  x_fc_aligned |> dplyr::select(mes, dplyr::all_of(x_vars)),
optimista = x_fc_aligned |>
dplyr::mutate(dplyr::across(dplyr::all_of(x_vars), ~ .x * escala_opt)) |>
dplyr::select(mes, dplyr::all_of(x_vars)),
pesimista = x_fc_aligned |>
dplyr::mutate(dplyr::across(dplyr::all_of(x_vars), ~ .x * escala_pes)) |>
dplyr::select(mes, dplyr::all_of(x_vars)),
names_to = ".scenario"
)

fc_scen <- fabletools::forecast(energia_arimax_fit, new_data = newdata_scen)
fc_scen

```



```{r}
#| echo: false

# Métricas de test

print(acc_test)

# Ex–ante (primeras filas)

print(fc_exante |> fabletools::as_fable() |> dplyr::as_tibble() |> dplyr::slice_head(n = 6))

# Escenarios (primeras filas por escenario)

print(fc_scen |> fabletools::as_fable() |> dplyr::as_tibble() |>
dplyr::group_by(.scenario) |> dplyr::slice_head(n = 6))

```


```{r}
#| echo: false

# Histórico vs ex–ante base

autoplot(energia_reg, !!rlang::sym(y_var)) +
autolayer(fc_exante, level = 95) +
labs(title = paste("ARIMAX –", y_var, "ex–ante (h =", h_meses, ")"),
x = NULL, y = y_var)

# Escenarios

autoplot(fc_scen) +
labs(title = paste("ARIMAX + escenarios (", y_var, ")", sep = ""),
x = NULL, y = y_var)

```

```{r}
#| echo: false
#| warning: false
#| message: false
# --- CHECKS para el ex–ante ---
if (length(x_fut_cols) == 0) {
  stop("No hay regresores X disponibles para el ex–ante (x_fut_cols está vacío). Revisa qué columnas entran a la fórmula.")
}

# Predicción ex–ante de Y con el modelo entrenado en todo el historial
y_fc_exante <- predict(modelo_reg_all, newdata = x_fut_newdata)

# Tabla ex–ante (36 meses)
exante_fc_tsb <- tibble::tibble(
  mes   = x_fut_newdata$mes,
  .mean = as.numeric(y_fc_exante)
) |>
  as_tsibble(index = mes)

# --- Mostrar/validar ---
# Debe tener 36 filas
print(dim(exante_fc_tsb))     # (36, 2)
print(exante_fc_tsb |> as_tibble() |> slice_head(n = 10))

# --- Plot ex–ante solo ---
ggplot(exante_fc_tsb, aes(x = mes, y = .mean)) +
  geom_line() +
  labs(title = "Pronóstico ex–ante a 36 meses (base)",
       x = NULL, y = y_var)

# --- Plot con historial para contexto (opcional) ---
hist_y <- datos_reg |>
  select(mes, !!y_var) |>
  rename(y_hist = !!sym(y_var))

ggplot() +
  geom_line(data = hist_y, aes(x = mes, y = y_hist)) +
  geom_line(data = exante_fc_tsb, aes(x = mes, y = .mean), linetype = "dashed") +
  labs(title = "Histórico vs ex–ante (base) a 36 meses",
       x = NULL, y = y_var)
```
