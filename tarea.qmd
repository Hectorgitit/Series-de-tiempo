---
title: "Serie de electricidad"
format: 
  revealjs:
    scrollable: true
    incremental: true
    smaller: true
    theme: default
    embed-resources: true
execute:
  echo: true
  output-location: column-fragment
---


```{r}
#| echo: false
#| warning: false
#| message: false
# --- ARIMA por serie + LM (fórmula automática según columnas disponibles) ---

library(tidyquant)
library(tsibble)
library(fable)
library(fabletools)
library(feasts)
library(lubridate)
library(dplyr)
library(tidyr)
library(ggplot2)
library(stringr)
library(glue)
```

```{r}
#| echo: false
#| warning: false
#| message: false
h_meses <- 36
y_var   <- "IPN221114T8N"   
escala_opt <- 0.97          
escala_pes <- 1.03           
```



¿Qué buscamos pronosticar?




## Serie IPN221114T8N

Volumen de la generación eléctrica, pero **¿De qué fuentes?**

De las NAICS (North American Industry Classification System)
NAICS 221114–221118:

-221114 **Solar**

-221115 **Eólica**

-221116 **Geotérmica**

-221117 **Biomasa**

-221118 **Otras**

Es decir, no incluye: 

-221112 Fossil Fuel Electric Power Generation (**carbón**, **gas natural**, **fuel-oil**)

-221113 **Nuclear**

-221111 **Hidroeléctrica** (renovable, pero va aparte en NAICS)



```{r}
#| echo: false
#| warning: false
#| message: false
#| fig.show: hold

# 1) Descargar y preparar
ip_renov_us_raw <- tq_get("IPN221114T8N", get = "economic.data") |>
  transmute(mes = yearmonth(date), valor = price)

ip_renov_us <- ip_renov_us_raw |>
  group_by(mes) |>
  summarise(valor = mean(valor, na.rm = TRUE), .groups = "drop") |>
  as_tsibble(index = mes)

# 2) Calidad de datos (sin imprimir en el render)
invisible(glimpse(ip_renov_us))
invisible(interval(ip_renov_us))
invisible(has_gaps(ip_renov_us)); invisible(count_gaps(ip_renov_us))

# 3) Serie, STL y estacionalidad (asignar y luego imprimir)

# Serie
p1 <- autoplot(ip_renov_us, valor) +
  labs(title = "IPN221114T8N – índice (2017=100, no ajustado)", x = NULL, y = NULL)
print(p1)

# STL
stl_comps <- ip_renov_us |>
  model(STL(valor ~ trend(window = 13) + season(window = "periodic"))) |>
  components()
p2 <- autoplot(stl_comps) +
  labs(title = "Descomposición STL")
print(p2)

# Estacionalidad por mes
p3 <- gg_season(ip_renov_us, valor) +
  labs(title = "Estacionalidad por mes", x = "Mes", y = NULL)
print(p3)

# 4) Fuerza de tendencia/estacionalidad (calculado pero NO mostrado)
feats <- ip_renov_us |>
  features(valor, feat_stl) |>
  select(trend_strength, seasonal_strength_year)
invisible(feats)

# Evitar auto-impresión al final del chunk
invisible(NULL)
```
```{r}
# 2) Calidad de datos
glimpse(ip_renov_us)
interval(ip_renov_us)
has_gaps(ip_renov_us); count_gaps(ip_renov_us)

# 3) Serie, STL y estacionalidad
autoplot(ip_renov_us, valor) +
  labs(title = "IPN221114T8N – índice (2017=100, no ajustado)", x = NULL, y = NULL)

ip_renov_us |>
  model(STL(valor ~ trend(window = 13) + season(window = "periodic"))) |>
  components() |>
  autoplot() +
  labs(title = "Descomposición STL")

gg_season(ip_renov_us, valor) +
  labs(title = "Estacionalidad por mes", x = "Mes", y = NULL)
```


## ¿Qué sería lo lógico?
Buscar series que no sean redundantes con energías renovables.

MHHNGSP - **Precio spot del gas natural** en el punto Henry Hub (referencia para EE. UU.).

WPS0554 - **Índice de precios al productor para gas natural** destinado a la generación eléctrica.

NATURALGAS - **Consumo total de gas natural** en EE. UU.

##

DCOILWTICO - **Precio promedio del petróleo crudo** WTI (referencia mundial).

IPUTIL - **Producción industrial real del sector de servicios públicos** (electricidad, agua, gas).

APU000072610 - **Precio promedio minorista de la electricidad** en hogares de EE. UU.

INDPRO - **Producción industrial** total de EE. UU. (todos los sectores).

CPIENGSL - CPI: “Energy Services” (electricidad + gas para el hogar) – **consumidores urbanos**.

```{r}
#| echo: false
#| warning: false
#| message: false

# 1) Lista deseada (si alguna no existe en FRED o falla la conexión, la omitiremos)
vars_fred <- c(
  "IPN221114T8N",                 # objetivo
  "MHHNGSP","WPS0554","NATURALGAS","DCOILWTICO","IPUTIL",
  "GASPRICE","APU000072610","CO2EMISS","INDPRO","TEMPUS","CPIENGSL"
)
vars_fred

```

```{r}
#| echo: false
#| warning: false
#| message: false
# 2) Descargar y mensualizar
energia_raw <- tq_get(vars_fred, get = "economic.data") |>
  rename(serie = symbol, valor = price)
energia_raw
```

```{r}
#| echo: false
#| warning: false
#| message: false
# 2.1) Reportar qué series sí bajaron y cuáles faltaron
series_ok  <- energia_raw |> distinct(serie) |> pull(serie)
series_out <- setdiff(vars_fred, series_ok)
message("Series descargadas: ", paste(series_ok, collapse = ", "))
if (length(series_out) > 0) {
  message("⚠️ No se descargaron (se excluirán): ", paste(series_out, collapse = ", "))
}
series_ok
```

```{r}

energia_mensual_tsb <- energia_raw |>
  transmute(serie, mes = yearmonth(date), valor) |>
  group_by(serie, mes) |>
  summarise(valor = mean(valor, na.rm = TRUE), .groups = "drop") |>
  as_tsibble(index = mes, key = serie) |>
  arrange(serie, mes)
energia_mensual_tsb
```

```{r}
#| echo: false

# Panel WIDE con observadas (Y + X) a partir de energia_mensual_tsb

energia_panel_wide <- energia_mensual_tsb |>
dplyr::as_tibble() |>
tidyr::pivot_wider(names_from = serie, values_from = valor) |>
dplyr::arrange(mes) |>
tsibble::as_tsibble(index = mes)

# Selección de regresores disponibles

candidatas_x <- setdiff(vars_fred, y_var)
x_vars <- intersect(candidatas_x, names(energia_panel_wide))

stopifnot(y_var %in% names(energia_panel_wide), length(x_vars) > 0)

# Fórmula ARIMAX (órdenes auto + xregs)

fmla_arimax <- as.formula(paste(y_var, "~", paste(x_vars, collapse = " + ")))

# Datos limpios (sin NA en Y ni X)

energia_reg <- energia_panel_wide |>
dplyr::select(mes, dplyr::all_of(c(y_var, x_vars))) |>
tidyr::drop_na()

# Ajuste ARIMAX

energia_arimax_fit <- energia_reg |>
fabletools::model(arimax = fable::ARIMA(fmla_arimax))

# Diagnóstico breve

fabletools::report(energia_arimax_fit)

```


```{r}
#MHHNGSP - Precio spot del gas natural en el punto Henry Hub (referencia para EE. UU.).
#WPS0554 - Índice de precios al productor para gas natural destinado a la generación eléctrica.
#NATURALGAS - Consumo total de gas natural en EE. UU.
#DCOILWTICO - Precio promedio del petróleo crudo WTI (referencia mundial).
#IPUTIL - Producción industrial real del sector de servicios públicos (electricidad, agua, gas).
#APU000072610 - Precio promedio minorista de la electricidad en hogares de EE. UU.
#INDPRO - Producción industrial total de EE. UU. (todos los sectores).
```




## Eliminamos una variable no significativa
Optimización 1

```{r}
#| echo: false

# Elimina una X, actualiza fórmula y re-ajusta ARIMAX

var_out <- "NATURALGAS"   # <-- cambia aquí el nombre a eliminar
resp <- all.vars(fmla_arimax)[1]
xs   <- setdiff(all.vars(fmla_arimax)[-1], var_out)
stopifnot(length(xs) > 0)
fmla_arimax <- reformulate(xs, response = resp)

energia_arimax_fit <- energia_reg |>
fabletools::model(arimax = fable::ARIMA(fmla_arimax))

fabletools::report(energia_arimax_fit)

```


## Eliminamos otra variable no significativa
Optimización 2
```{r}
#| echo: false

# Elimina una X, actualiza fórmula y re-ajusta ARIMAX

var_out <- "DCOILWTICO"   # <-- cambia aquí el nombre a eliminar
resp <- all.vars(fmla_arimax)[1]
xs   <- setdiff(all.vars(fmla_arimax)[-1], var_out)
stopifnot(length(xs) > 0)
fmla_arimax <- reformulate(xs, response = resp)

energia_arimax_fit <- energia_reg |>
fabletools::model(arimax = fable::ARIMA(fmla_arimax))

fabletools::report(energia_arimax_fit)

```

## Eliminamos otra variable no significativa
Optimización 3

```{r}
#| echo: false

# Elimina una X, actualiza fórmula y re-ajusta ARIMAX

var_out <- "WPS0554"   # <-- cambia aquí el nombre a eliminar
resp <- all.vars(fmla_arimax)[1]
xs   <- setdiff(all.vars(fmla_arimax)[-1], var_out)
stopifnot(length(xs) > 0)
fmla_arimax <- reformulate(xs, response = resp)

energia_arimax_fit <- energia_reg |>
fabletools::model(arimax = fable::ARIMA(fmla_arimax))

fabletools::report(energia_arimax_fit)

```


## Eliminamos ya la última no significativa
Optimización 4

```{r}
#| echo: false

# Elimina una X, actualiza fórmula y re-ajusta ARIMAX

var_out <- "APU000072610"   # <-- cambia aquí el nombre a eliminar
resp <- all.vars(fmla_arimax)[1]
xs   <- setdiff(all.vars(fmla_arimax)[-1], var_out)
stopifnot(length(xs) > 0)
fmla_arimax <- reformulate(xs, response = resp)

energia_arimax_fit <- energia_reg |>
fabletools::model(arimax = fable::ARIMA(fmla_arimax))

fabletools::report(energia_arimax_fit)

```

## Reflexión
En el caso de esta regresión en específico solo eliminares el consumo total de gas natural en EU ya que las demas solo reducen el R cuadrado ajustado, lo cual es lo que se puede explicar de la variable a pronosticar.

```{r}
#| echo: false

# Horizonte

h_meses <- 36

# Corte temporal

ultimo_mes <- max(energia_reg$mes)
corte_test <- ultimo_mes - (h_meses - 1)

train <- energia_reg |> dplyr::filter(mes <  corte_test)
test  <- energia_reg |> dplyr::filter(mes >= corte_test)

# Re-ajustar ARIMAX en TRAIN

fit_train <- train |> fabletools::model(arimax = fable::ARIMA(fmla_arimax))

# Pronóstico sobre TEST (X observadas)

fc_test <- fabletools::forecast(
fit_train,
new_data = test |> dplyr::select(mes, dplyr::all_of(setdiff(all.vars(fmla_arimax), all.vars(fmla_arimax)[1])))
)

# Métricas contra Y observada

acc_test <- fabletools::accuracy(fc_test, test)
acc_test

```

```{r arimax_exante}
#| echo: false
# EX–ANTE con ARIMAX — horizonte fijo y new_data con misma estructura que el entrenamiento

# 1) Recojo los regresores vigentes (por si quitaste alguno en “Optimización”)
x_vars <- setdiff(all.vars(fmla_arimax), all.vars(fmla_arimax)[1])

# 2) Último mes observado en el set de entrenamiento del ARIMAX
ultimo_hist <- max(energia_reg$mes)  # yearmonth

# 3) Plantilla de horizonte: EXACTAMENTE los próximos h_meses (como tsibble)
fut_index <- tibble::tibble(
  mes = tsibble::yearmonth(ultimo_hist) + seq_len(h_meses)
) |> tsibble::as_tsibble(index = mes)

# 4) Pronóstico ARIMA de cada X usando la plantilla (no 'h')
x_series <- energia_mensual_tsb |> dplyr::filter(serie %in% x_vars)
x_fit    <- x_series |> fabletools::model(auto = fable::ARIMA(valor))

x_fc <- x_fit |>
  fabletools::forecast(new_data = fut_index) |>   # forzamos fechas futuras correctas
  dplyr::mutate(valor_fc = mean(valor)) |>        # punto (media de la distribución)
  dplyr::as_tibble() |>
  dplyr::select(serie, mes, valor_fc) |>
  tidyr::pivot_wider(names_from = serie, values_from = valor_fc) |>
  dplyr::arrange(mes) |>
  dplyr::mutate(dplyr::across(dplyr::all_of(x_vars), as.numeric))

# 5) new_data para ARIMAX:
#    partimos de 'fut_index' (tsibble) -> pegamos X -> dejamos SOLO mes + X
#    y RECONVERTIMOS a tsibble (esto evita el error de "different key structure")
new_data_exante <- fut_index |>
  dplyr::left_join(x_fc, by = "mes") |>
  dplyr::select(mes, dplyr::all_of(x_vars)) |>
  tsibble::as_tsibble(index = mes)   # << clave: mismo index/key que el modelo

# 6) Ex–ante (base) de Y con ARIMAX
fc_exante <- fabletools::forecast(
  energia_arimax_fit,
  new_data = new_data_exante
)

fc_exante
```




```{r}
#| echo: false
# Escenarios con fabletools::scenarios()

# Por seguridad, vuelvo a tomar los regresores vigentes
x_vars <- setdiff(all.vars(fmla_arimax), all.vars(fmla_arimax)[1])

escala_opt <- 0.97  # -3%
escala_pes <- 1.03  # +3%

newdata_scen <- fabletools::scenarios(
  base =  x_fc_aligned |>
    dplyr::select(mes, dplyr::all_of(x_vars)) |>
    tsibble::as_tsibble(index = mes),
  optimista = x_fc_aligned |>
    dplyr::mutate(dplyr::across(dplyr::all_of(x_vars), ~ .x * escala_opt)) |>
    dplyr::select(mes, dplyr::all_of(x_vars)) |>
    tsibble::as_tsibble(index = mes),
  pesimista = x_fc_aligned |>
    dplyr::mutate(dplyr::across(dplyr::all_of(x_vars), ~ .x * escala_pes)) |>
    dplyr::select(mes, dplyr::all_of(x_vars)) |>
    tsibble::as_tsibble(index = mes),
  names_to = ".scenario"
)

fc_scen <- fabletools::forecast(energia_arimax_fit, new_data = newdata_scen)
fc_scen
```

